import chromadb
from chromadb.config import Settings
import os
from app.utils.logger import logger
from app.services.ollama_client import ollama_client
from typing import List, Optional, Dict, Any

class ContextManager:
    def __init__(self):
    self.chroma_host = os.getenv("CHROMA_HOST", "localhost")
    self.chroma_port = os.getenv("CHROMA_PORT", "8003")
    
    try:
        # Configuraci√≥n para ChromaDB con API v2
        self.chroma_client = chromadb.HttpClient(
            host=self.chroma_host,
            port=self.chroma_port,
            settings=Settings(
                chroma_api_impl="rest",
                chroma_server_headers={}
            )
        )
        
        # Verificar conexi√≥n con la API v2
        heartbeat = self.chroma_client.heartbeat()
        logger.info(f"‚úÖ Conectado a ChromaDB. Heartbeat: {heartbeat}")
        
        # Crear o obtener la colecci√≥n
        self.collection = self.chroma_client.get_or_create_collection(
            name="claude_chat_sessions",
            metadata={"hnsw:space": "cosine"}
        )
        logger.info("‚úÖ Colecci√≥n de ChromaDB inicializada")
        
    except Exception as e:
        logger.error(f"‚ùå Error inicializando ChromaDB: {str(e)}")
        raise e
        
    """
    def __init__(self):
        self.chroma_host = os.getenv("CHROMA_HOST", "localhost")
        self.chroma_port = os.getenv("CHROMA_PORT", "8000")
        try:
            self.chroma_client = chromadb.HttpClient(
                host=self.chroma_host, 
                port=self.chroma_port,
                settings=Settings(allow_reset=True)
            )
            self.collection = self.chroma_client.get_or_create_collection(
                name="claude_chat_sessions",
                metadata={"hnsw:space": "cosine", "description": "Storage for Claude chat context"}
            )
            logger.info(f"‚úÖ Conectado a ChromaDB en {self.chroma_host}:{self.chroma_port}")
        except Exception as e:
            logger.error(f"‚ùå Error conectando a ChromaDB: {str(e)}")
            raise

    async def _get_embeddings(self, text: str) -> List[float]:
        """Obtiene embeddings para un texto usando el modelo nomic-embed-text."""
        try:
            embedding = await ollama_client.get_embeddings(text)
            if not embedding:
                logger.warning("‚ö†Ô∏è  No se pudieron generar embeddings, usando vector vac√≠o")
                return [0.0] * 768  # Vector de fallback
            return embedding
        except Exception as e:
            logger.error(f"‚ùå Error generando embeddings: {str(e)}")
            return [0.0] * 768
    """
    async def get_all_sessions(self) -> List[str]:
        """Obtiene todas las sesiones √∫nicas almacenadas en ChromaDB."""
        try:
            # Obtener todos los metadatos (solo necesitamos los metadatos)
            results = self.collection.get(
                include=[],  # No incluir documentos ni embeddings
                limit=10000   # L√≠mite alto para obtener todas las sesiones
            )
            
            # Extraer session_ids √∫nicos de los metadatos
            sessions = set()
            if results and results['metadatas']:
                for metadata in results['metadatas']:
                    if metadata and 'session_id' in metadata:
                        sessions.add(metadata['session_id'])
            
            logger.info(f"üìä Sesiones encontradas: {len(sessions)}")
            return list(sessions)
            
        except Exception as e:
            logger.error(f"‚ùå Error obteniendo sesiones de ChromaDB: {str(e)}")
            return []  # Devolver lista vac√≠a en caso de error
    """
    """
    async def add_interaction(self, session_id: str, user_message: str, ai_response: str, metadata: Optional[Dict] = None):
        """Almacena un intercambio completo en la base de datos vectorial."""
        try:
            full_interaction = f"User: {user_message}\nAssistant: {ai_response}"
            
            # Generar embedding
            embedding = await self._get_embeddings(full_interaction)
            
            # Metadata adicional
            interaction_metadata = {
                "session_id": session_id,
                "type": "interaction",
                "user_message_length": len(user_message),
                "ai_response_length": len(ai_response),
                "timestamp": os.times().user,
                **(metadata or {})
            }
            
            # ID √∫nico para el documento
            doc_id = f"{session_id}_{os.times().user}_{hash(full_interaction)}"
            
            # Almacenar en ChromaDB
            self.collection.add(
                documents=[full_interaction],
                embeddings=[embedding],
                metadatas=[interaction_metadata],
                ids=[doc_id]
            )
            
            logger.info(f"üíæ Interacci√≥n almacenada para sesi√≥n '{session_id}'")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error almacenando interacci√≥n: {str(e)}")
            return False
    """
    async def add_interaction(self, session_id: str, user_message: str, ai_response: str, metadata: dict = None):
    """Almacena un intercambio (pregunta + respuesta) en la base de datos vectorial (API v2)."""
    full_interaction = f"Usuario: {user_message}\nClaude: {ai_response}"
    
    try:
        # Generar embedding para el intercambio completo
        embedding = await self._get_embeddings(full_interaction)
        if not embedding:
            logger.warning(f"‚ö†Ô∏è No se pudo generar embedding para la interacci√≥n en sesi√≥n {session_id}")
            return False

        # Preparar metadatos
        interaction_metadata = {"session_id": session_id, "type": "interaction"}
        if metadata:
            interaction_metadata.update(metadata)

        # Almacenar en ChromaDB (API v2)
        self.collection.add(
            documents=[full_interaction],
            embeddings=[embedding],
            metadatas=[interaction_metadata],
            ids=[f"{session_id}_{hash(full_interaction)}_{datetime.now().timestamp()}"]
        )
        
        logger.info(f"üíæ Interacci√≥n almacenada para sesi√≥n {session_id}")
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Error almacenando interacci√≥n: {str(e)}")
        return False
    """
    async def get_relevant_context(self, session_id: str, query: str, n_results: int = 5) -> List[str]:
        """Recupera contexto relevante para una consulta espec√≠fica."""
        try:
            # Generar embedding para la consulta
            query_embedding = await self._get_embeddings(query)
            
            # Buscar en ChromaDB filtrado por session_id
            results = self.collection.query(
                query_embeddings=[query_embedding],
                n_results=n_results,
                where={"session_id": session_id},
                include=["documents", "metadatas", "distances"]
            )
            
            if results and results['documents']:
                relevant_docs = results['documents'][0]
                logger.info(f"üîç Encontrados {len(relevant_docs)} contextos relevantes para sesi√≥n '{session_id}'")
                
                # Ordenar por distancia (mayor relevancia primero) y formatear
                formatted_context = []
                for i, (doc, metadata, distance) in enumerate(zip(
                    relevant_docs, 
                    results['metadatas'][0], 
                    results['distances'][0]
                )):
                    formatted_context.append(f"[Relevancia: {1-distance:.3f}] {doc}")
                
                return formatted_context
                
            return []
            
        except Exception as e:
            logger.error(f"‚ùå Error recuperando contexto: {str(e)}")
            return []
    """
async def get_relevant_context(self, session_id: str, query: str, n_results: int = 3) -> List[str]:
    """Recupera los intercambios m√°s relevantes de una sesi√≥n para una consulta dada (API v2)."""
    try:
        # Generar embedding para la consulta actual
        query_embedding = await self._get_embeddings(query)
        if not query_embedding:
            logger.warning("‚ö†Ô∏è No se pudo generar embedding para la query de b√∫squeda")
            return []

        # Buscar en ChromaDB (API v2), filtrando por la session_id
        results = self.collection.query(
            query_embeddings=[query_embedding],
            n_results=n_results,
            where={"session_id": session_id}  # Filtro por sesi√≥n
        )
        
        if results and results['documents']:
            logger.info(f"üìö Se recuperaron {len(results['documents'][0])} contextos relevantes para la sesi√≥n {session_id}")
            return results['documents'][0]
        
        return []
        
    except Exception as e:
        logger.error(f"‚ùå Error buscando contexto relevante: {str(e)}")
        return []

    async def get_session_summary(self, session_id: str) -> Optional[str]:
        """Genera un resumen de toda la sesi√≥n usando Ollama."""
        try:
            # Obtener todas las interacciones de la sesi√≥n
            session_interactions = self.collection.get(
                where={"session_id": session_id},
                include=["documents"]
            )
            
            if not session_interactions['documents']:
                return None
                
            # Unir todas las interacciones para el resumen
            all_text = "\n\n".join(session_interactions['documents'])
            
            # Usar Ollama para generar un resumen
            summary = await ollama_client.generate_summary(all_text, session_id)
            return summary
            
        except Exception as e:
            logger.error(f"‚ùå Error generando resumen de sesi√≥n: {str(e)}")
            return None

# Instancia global del gestor de contexto (inicializaci√≥n diferida)
_context_manager_instance = None

def get_context_manager():
    global _context_manager_instance
    if _context_manager_instance is None:
        try:
            _context_manager_instance = ContextManager()
            logger.info("‚úÖ Context Manager inicializado exitosamente")
        except Exception as e:
            logger.error(f"‚ùå Error inicializando Context Manager: {str(e)}")
            # Crear una instancia dummy para evitar errores de importaci√≥n
            class DummyContextManager:
                async def add_interaction(self, *args, **kwargs): return False
                async def get_relevant_context(self, *args, **kwargs): return []
                async def get_session_summary(self, *args, **kwargs): return None
                async def get_all_sessions(self, *args, **kwargs): return []  # ‚Üê A√ëADIR ESTE M√âTODO
            _context_manager_instance = DummyContextManager()
    return _context_manager_instance

# Alias para compatibilidad
context_manager = get_context_manager()
