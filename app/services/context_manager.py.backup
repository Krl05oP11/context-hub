import chromadb
from datetime import datetime
from chromadb.config import Settings
import os
from app.utils.logger import logger
from app.services.ollama_client import ollama_client
from typing import List, Optional, Dict, Any


class ContextManager:
    def __init__(self):
        try:
            # MODO EMBEBIDO - Sin servidor, datos locales
            self.chroma_client = chromadb.PersistentClient(
                path="./chroma_data"  # Carpeta local para datos
            )
            
            # Test de conexi√≥n
            heartbeat = self.chroma_client.heartbeat()
            logger.info(f"‚úÖ Heartbeat de ChromaDB: {heartbeat}")
            
            # INTENTAR OBTENER COLECCI√ìN EXISTENTE
            try:
                self.collection = self.chroma_client.get_collection(
                    name="claude_chat_sessions"
                )
                logger.info("‚úÖ Colecci√≥n existente obtenida")
                
            except Exception as e:
                # SI NO EXISTE, CREARLA
                logger.warning(f"‚ö†Ô∏è Colecci√≥n no existe, creando: {str(e)}")
                try:
                    self.collection = self.chroma_client.create_collection(
                        name="claude_chat_sessions"
                        # Sin metadata inicial para evitar errores
                    )
                    logger.info("‚úÖ Nueva colecci√≥n creada")
                except Exception as create_error:
                    if "already exists" in str(create_error):
                        # La colecci√≥n ya fue creada por otra instancia
                        self.collection = self.chroma_client.get_collection("claude_chat_sessions")
                        logger.info("‚úÖ Colecci√≥n obtenida despu√©s de error de creaci√≥n")
                    else:
                        logger.error(f"‚ùå Error creando colecci√≥n: {str(create_error)}")
                        raise
            
            logger.info("‚úÖ Conectado a ChromaDB en modo embebido")
            
        except Exception as e:
            logger.error(f"‚ùå Error conectando a ChromaDB: {str(e)}")
            self.chroma_client = None
            self.collection = None

    def is_connected(self):
        return self.chroma_client is not None and self.collection is not None

    async def _get_embeddings(self, text: str) -> List[float]:
        """Obtiene embeddings para un texto usando el modelo nomic-embed-text."""
        try:
            embedding = await ollama_client.get_embeddings(text)
            if not embedding:
                logger.warning("‚ö†Ô∏è No se pudieron generar embeddings, usando vector vac√≠o")
                return [0.0] * 384  # nomic-embed-text usa 384 dimensiones
            return embedding
        except Exception as e:
            logger.error(f"‚ùå Error generando embeddings: {str(e)}")
            return [0.0] * 384

    async def get_all_sessions(self) -> List[str]:
        """Obtiene todas las sesiones √∫nicas almacenadas en ChromaDB."""
        try:
            if not self.is_connected():
                return []
                
            # Para API v2, usar get() con where filtro vac√≠o
            results = self.collection.get(
                where={},  # Sin filtros para obtener todo
                include=["metadatas"],
                limit=1000
            )

            # Extraer session_ids √∫nicos de los metadatos
            sessions = set()
            if results and results['metadatas']:
                for metadata in results['metadatas']:
                    if metadata and 'session_id' in metadata:
                        sessions.add(metadata['session_id'])

            logger.info(f"üìä Sesiones encontradas: {len(sessions)}")
            return list(sessions)

        except Exception as e:
            logger.error(f"‚ùå Error obteniendo sesiones de ChromaDB: {str(e)}")
            return []

    async def add_interaction(
            self,
            session_id: str,
            user_message: str,
            ai_response: str,
            metadata: Optional[Dict] = None):
            logger.info(f"üîÑ Intentando almacenar interacci√≥n para sesi√≥n: {session_id}")
        """Almacena un intercambio completo en la base de datos vectorial."""
        try:
            if not self.is_connected():
                return False
                
            full_interaction = f"User: {user_message}\nAssistant: {ai_response}"

            # Generar embedding
            embedding = await self._get_embeddings(full_interaction)

            # Metadata adicional
            interaction_metadata = {
                "session_id": session_id,
                "type": "interaction",
                "user_message_length": len(user_message),
                "ai_response_length": len(ai_response),
                "timestamp": datetime.now().isoformat(),
                **(metadata or {})
            }

            # ID √∫nico para el documento
            doc_id = f"{session_id}_{datetime.now().timestamp()}_{hash(full_interaction)}"

            # Almacenar en ChromaDB
            self.collection.add(
                documents=[full_interaction],
                embeddings=[embedding],
                metadatas=[interaction_metadata],
                ids=[doc_id]
            )

            logger.info(f"üíæ Interacci√≥n almacenada para sesi√≥n '{session_id}'")
            logger.info(f"‚úÖ Interacci√≥n ALMACENADA EXITOSAMENTE: {session_id}")
            return True

        except Exception as e:
            logger.error(f"‚ùå Error almacenando interacci√≥n: {str(e)}")
            return False

    async def get_relevant_context(
            self,
            session_id: str,
            query: str,
            n_results: int = 5) -> List[str]:
        """Recupera contexto relevante para una consulta espec√≠fica."""
        try:
            if not self.is_connected():
                return []
                
            # Generar embedding para la consulta
            query_embedding = await self._get_embeddings(query)

            # Buscar en ChromaDB filtrado por session_id
            results = self.collection.query(
                query_embeddings=[query_embedding],
                n_results=n_results,
                where={"session_id": session_id},
                include=["documents", "metadatas", "distances"]
            )

            if results and results['documents']:
                relevant_docs = results['documents'][0]
                logger.info(f"üîç Encontrados {len(relevant_docs)} contextos relevantes para sesi√≥n '{session_id}'")

                # Filtrar por relevancia (distancia < 1.0 = relevante)
                formatted_context = []
                for doc, distance in zip(relevant_docs, results['distances'][0]):
                    if distance < 1.5:  # Umbral de relevancia
                        formatted_context.append(doc)

                return formatted_context

            return []

        except Exception as e:
            logger.error(f"‚ùå Error recuperando contexto: {str(e)}")
            return []

    async def get_session_summary(self, session_id: str) -> Optional[str]:
        """Genera un resumen de toda la sesi√≥n usando Ollama."""
        try:
            if not self.is_connected():
                return None
                
            # Obtener todas las interacciones de la sesi√≥n
            session_interactions = self.collection.get(
                where={"session_id": session_id},
                include=["documents"]
            )

            if not session_interactions['documents']:
                return None

            # Unir todas las interacciones para el resumen
            all_text = "\n\n".join(session_interactions['documents'])

            # Usar Ollama para generar un resumen
            summary = await ollama_client.generate_summary(all_text, session_id)
            return summary

        except Exception as e:
            logger.error(f"‚ùå Error generando resumen de sesi√≥n: {str(e)}")
            return None


# Instancia global del gestor de contexto (inicializaci√≥n diferida)
_context_manager_instance = None


def get_context_manager():
    global _context_manager_instance
    if _context_manager_instance is None:
        try:
            _context_manager_instance = ContextManager()
            logger.info("‚úÖ Context Manager inicializado exitosamente")
        except Exception as e:
            logger.error(f"‚ùå Error inicializando Context Manager: {str(e)}")
            # Crear una instancia dummy para evitar errores de importaci√≥n
            class DummyContextManager:
                def is_connected(self): return False
                async def _get_embeddings(self, text: str): return [0.0] * 384
                async def get_all_sessions(self): return []
                async def add_interaction(self, *args, **kwargs): return False
                async def get_relevant_context(self, *args, **kwargs): return []
                async def get_session_summary(self, *args, **kwargs): return None
                
            _context_manager_instance = DummyContextManager()
    return _context_manager_instance


# Alias para compatibilidad
context_manager = get_context_manager()
